<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>guide on Wound:Abser&#39;s Blog</title>
    <link>https://blog.abser.top/tags/guide/</link>
    <description>Recent content in guide on Wound:Abser&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 12 Mar 2019 12:06:38 +0800</lastBuildDate>
    
	<atom:link href="https://blog.abser.top/tags/guide/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Studycoding</title>
      <link>https://blog.abser.top/blog/studycoding/</link>
      <pubDate>Tue, 12 Mar 2019 12:06:38 +0800</pubDate>
      
      <guid>https://blog.abser.top/blog/studycoding/</guid>
      <description>我是如何开始学习编码的：前三个月我用过的资源 想学习如何编程？本文将指导你经过技术和资源的丛林，帮助你从无知识到构建快速、互动、现代的编码知识，沿着我走过的林间小径。
从八月底到十二月初
我花了三个月的时间学习编码，虽然有时候很有挑战性，但这是一次非常有益的体验。
最棘手的一个挑战是选择_什么样_的学习和_在那里_学习它。有这么多的语言，框架和库 - 以及许多相互矛盾的建议。
此外，一些学习资源比其他学习资源要好得多。如果我知道要关注哪些资源，我的进展可能会更快。
本着这种精神，我想我会分享对我有用的东西。如果感觉很多，我很幸运，我每天可以花几个小时学习这些材料。你做得多快并不代表你作为开发者的潜力，所以不要担心是否需要更长的时间来完成这些材料。但是，如果你能投入时间，可以在半个月内完成。
这些是我经历过的路程，并不代表你需要全部走过

第一部分：HTML，CSS和JavaScript 这些是所有Web应用程序的三种核心语言，并且（几乎）不可能在不使用它们的情况下在Internet上构建任何内容。 
HTML 如果你以前从未做过任何编码，那么HTML就是一个很好的起点。它是互联网的核心构建块，与大多数其他语言不同，它为学习者提供了他们正在编写的代码的即时可视反馈。

CSS CSS是HTML的自然伴侣。从表面上看，它非常简单，虽然有一些概念 - 特别是与布局和定位有关 - 可能需要一些时间来解决问题。
CSS最困难的部分是理解布局。用户在StackOverflow上询问了我的大多数布局问题，因此快速的Google搜索解决了我的大多数问题。
H5 和 CSS 大概花去了我两天时间，通常你想了解一个编码方面的事物时，直接上手总是最快捷的方式。 
JavaScript HTML和CSS不是完全成熟的编程语言，因此在开始学习编程语言之前，您将无法完全了解编程。JavaScript是Web的编程语言。
平心而论，虽然我在初中时期尝试过 js 编程，然而连真正的编码都算不上，直至现在我也是 JavaScript 的菜鸟，所以这上面我并不能给予一些帮助建议
由于我开始学习后端，js 从熟悉拼写到知道历史花了我一小段时间。

GO Go 是极其酷的语言，尤其是在现代进行高效的 Web 编程方面
Go 是我学习后端被选择的语言，同时也是我越学越看好的语言。作为语言初学者的时候我还无法分辨各种语言的特性和好坏，这通常需要多年的编码经验或者有过使用多种语言的经历才能清楚。我经历过 C++ STL 的使用和一定的 Java 编码，但是从过来的眼光看待，不过是十数天就能达到的程度。
在 《The Way To Go》上我花费了大概三天时间，在此之前我阅读了菜鸟教程上关于 Go 语言的入门指南。虽然这本书对于 Go 语言的高级特性讲的比较简略，作为入门无疑是够的。即使我看的是英文，或许你也更喜欢拿着中文书籍看，但是作为编码人员，无疑英语才是必须学习的语言。
之后我进行了一个小爬虫的练习，涉及到 goquery，gocolly 先爬取的飞卢的小说网站，之后爬取的各个地区的各种商业信息。这大概花费了我一天的时间。（从这里学会的阅读文档的知识）
随后我开始了 Go 源码包的阅读，将每一个包的每一个函数遍历了一下他们的 godoc ，在我开始每一个函数的内在逻辑阅读时，我被中止了，由于庞大的知识体系。这大概花费了我三到四天。（从这里学会的画图技巧）
我这个时候开始使用社团的 Mac 电脑，开始了一个关于发送短信的云API接入服务的开发。当时了解并接入阿里云市场给我带来了麻烦，从需求找到解决方法向来非易事。这大概使用了一个星期，了解了关于 go 与 mysql 的接入，和不同终端的 HTTP 通信</description>
    </item>
    
    <item>
      <title>学习型组织概念</title>
      <link>https://blog.abser.top/blog/%E5%AD%A6%E4%B9%A0%E5%9E%8B%E7%BB%84%E7%BB%87%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Fri, 01 Mar 2019 17:19:45 +0800</pubDate>
      
      <guid>https://blog.abser.top/blog/%E5%AD%A6%E4%B9%A0%E5%9E%8B%E7%BB%84%E7%BB%87%E6%A6%82%E5%BF%B5/</guid>
      <description>学习型组织 释疑 
学习型组织的艺术与实践  以下大量原文引用自第五项修炼
 
学习型组织的真谛：活出生命的意义  许多人被问起，作为伟大团体一分子的经验是什么时，最引人深思的回答是：觉得自己属于一个比自我强大的事物的感觉，也就是大伙儿心手相连，共创未来的那种经验。对他们来说，作为真正伟大团体一分子的体验，是他们一生中最突出、生命力完全发挥的一段岁月。有些人竟其余生，希望寻求重温此种经历。
 在过去数百年来的西方文化中，有一个字很少被使用，但却可表达学习型组织的精神，这个字是metanoia，意思是心灵的转变。这十多年来在辅导企业时，我们私底下原先是用metanoic organization来形容学习型组织的。希腊文这个字的意思是心灵意念的根本改变，一种“超觉”的经验。在早期基督徒的传统中，这个字特指醒悟而直接觉知至高无上的、属于上帝的事物。在夭主教的经论中，这个字被翻译成“体悟生命的真义”。
 堂握metanoia的意义，等于掌握“学习”的更深层的意义，因为学习也包括心灵的根本转变或运作。然而学习在目前的用法上已经失去了它的核心意义。在日常用语上，学习已经变成吸收知识，或者是获得信息，然而这和真正的学习还有好大一段距离。
 真正的学习，涉及人之所以为人此一意义的核心。透过学习，我们重新创造自我。透过学习，我们能够做到从未能做到的事情，重新认知这个世界及我们跟它的关系，以及扩展创造未来的能量。事实上你我心底都深深地渴望这种真正的学习。
 这就是学习型组织的真谛。对这样的组织而言，单是适应与生存是不能满足它的。组织为适应与生存而学习，虽然是基本而必要的，但必须与开创性的学习结合起来，才能让大家在组织内由工作中活出生命的意义。
 目前，有些组织已扮演拓荒先锋的角色，朝这条路上走去。但学习型组织的领域，仍然大部分有待开垦。我衷心地期望这本书能加快开垦的速度。

学习型组织的五项修炼  今天，在学习型组织的领域里，也有五项新技术正逐渐汇聚起来，使学习型组织演变成一项创新。虽然，它们的发展是分开的，但都紧密相关，对学习型组织之建立，每一项都不可或缺。我们称这五项学习型组织的技能为五项修炼。以下，我们刻意将其中的核心“第五项修炼”先行介绍。

第五项修炼：系统思考（Systems Thinking）  当乌云密布、天色昏暗，我们便知道快要下雨了。我们也知道在暴风雨过后，地面的流水将渗入好几英里以外的地下水中，明日天空又要放晴。这一切的事件虽有时空的差距，然而事实上它们都息息相关，且每次运行的模式相同，每个环节都相互影响，这些影响通常是隐匿而不易被察觉的。惟有对整体、而不是对任何单独部分深入地加以思考，你才能够了解暴风雨的系统。
 企业和人类其他活动，也是一种“系统”，也都受到细微且息息相关的行动所牵连，彼此影响着，这种影响往往要经年累月才完全展现出来。身为群体中的一小部分，置身其中而想要看清整体变化，更是加倍的困难。我们因而倾向于将焦点放在系统中某一片段，但总想不通为什么有些最根本的问题似乎从来得不到解决。经过五十年的发展，系统思考已发展出一套思考的架构，它既具备完整的知识体系，也拥有实用的工具，可帮助我们认清整个变化形态，并了解应如何有效地掌握变化，开创新局。
 虽然工具是新的，系统思考的基本观念却是非常浅显的。我们的实验显示，小孩子学习系统思考时非常迅速。

第一项修炼：自我超越（Personal Mastery）  “自我超越”的修炼是学习不断厘清并加深个人的真正愿望，集中精力，培养耐心，并客观地观察现实。它是学习型组织的精神基础。精熟“自我超越”的人，能够不断实现他们内心深处最想实现的愿望，他们对生命的态度就如同艺术家对艺术作品一般，全心投入、不断创造和超越，是一种真正的终身“学习”。组织整体对于学习的意愿与能力，植基于个别成员对于学习的意愿与能力。此项修炼兼容并蓄了东方和西方的精神传统。
 遗憾的是，几乎没有任何组织鼓励他们的成员以这种方式成长。这个领域是一片庞大而尚未开发的处女地。汉诺瓦公司的欧白恩说：“企业的员工多半聪明、受过良好的教育、充满活力、全心全力渴望出人头地。但他们到了三十多岁时，通常只有少数平步青云，其余大多数人都失掉了开始时所有的企图心、使命感与兴奋感，对于工作，他们只投入些许精力，心灵几乎完全不在工作上。”这种组织设计所造成的个人生涯是多么可悲！
 而且令人惊讶的是，就个人而言，也只有少数的成年人努力发展本身，超越自我。当你询问成年人的愿望是什么，通常他们首先提到较负面的、想要除掉的人或事。例如他们说：“我想要我的岳母搬走”，或“我想要彻底治好背痛”。然而自我超越的修炼坝，是以厘清对我们真心向往的事情为起点，让我们为自己的最高愿望而活。
 这里，最有趣的部分是：个人学习与组织学习之间的关系、个人与组织之间的相互承诺，以及由一群“学习者”组成的企业所特有的精神。

第二项修炼：改善心智模式（Improving Mental Models）  “心智模式”是根深蒂固于心中，影响我们如何了解这个世界，以及如何采取行动的许多假设、成见，或甚至图象、印象。我们通常不易察觉自己的心智模式，以及它对行为的影响。例如，对于常说笑话的人，我们可能认为他乐观豁达；对于不修边幅的人，我们可能觉得他不在乎别人的想法。在管理的许多决策模式中，决定什么可以做或不可以做，也常是一种根深蒂固的心智模式。如果你无法掌握市场的契机和推行组织中的兴革，很可能是因为它们与我们心中隐藏的、强而有力的心智模式相抵触。
 壳牌石油公司是第一家了解加速组织学习好处的大企业，他们发现隐藏的心智模式影响既深且广，尤其是当它成为共有的心智模式时。壳牌石油公司之所以能成功地度过1970和八十年代石油危机的巨大冲击，主要归功于学习如何浮现管理者的心智模式，并加以改善。（在七十年代初期，壳牌石油在世界七大石油公司中敬陪末座；到八十年代末，它已经成了最强的一家）。最近刚由壳牌石油公司退休的企画主任德格说：“要在变动的企业环境中持续调适与成长，有赖组织化的学习，这是管理团体改变对公司、市场与竞争者的共有心智模式的过程。因此我们把企画看成学习，而把公司整体企画看作组织化的学习。”
 把镜子转向自己，是心智模式修炼的起步；借此，我们学习发掘内心世界的图象，使这些图象浮上表面，并严加审视。它还包活进行一种有学习效果的、兼顾质疑与表达的交谈能力——有效地表达自己的想法，并以开放的心灵容纳别人的想法。

第三项修炼：建立并同愿景（Building Shared Vision） _
如果有任何一项领导的理念，几千年来一直能在组织中鼓舞人心，那就是拥有＿种能够凝聚、并坚持实现共同的愿景的能力。一个缺少全体衷心共有的目标、价值观与使命的组织，必定难成大器。IBM公司以“服务”，拍立得公司以“立即摄影”；福特汽车公司以“提供大众公共运输”；苹果电脑公司以“提供大众强大的计算能力”为组织共同努力的最高鹄的。这些组织都在设法以共同的愿景把大家凝聚在一起。
 有了衷心渴望实现的目标，大家会努力学习、追求卓越，不是因为他们被要求这样做，而是因为衷心想要如此。但是许多领导者从未尝试将个人的愿景，转化为能够鼓舞组织的共同愿景。共同的愿景也常以一个伟大的领袖为中心，或激发自一件共同的危机。但是，如果有选择的余地，大多数的人会选择追求更高的目标，而并非只暂时解决危机。组织所缺少的，是将个人的愿景整合为共同愿景的修炼——注意我指的不是一本按部执行的手册，而是一套引导学习的原则。
 共同愿景的整合，涉及发掘共有“未来景象”的技术，它帮助组织培养成员主动而真诚地奉献和投入，而非被动的遵从。领导者在精熟此项修炼的过程中，会得到同样的教训：一味试图主导共同愿景（无论多么的有善意）会产生反效果。

第四项修炼：团体学习（Teaml，Learing）  在一个管理团体中，大家都认真参与，每个人的智商都在一百二十以上，何以集体的智商只有六十二？团体学习的修炼即在处理这种困境。然而我们知道团体确实能够共同学习；在运动、表演艺术、科学界，甚至企业中，有不少惊人的实例显示，团体的集体智慧高干个人智慧，团体拥有整体搭配的行动能力。当团体真正在学习的时候，不仅团体整体产生出色的成果，个别成员成长的速度也比其他的学习方式为快。</description>
    </item>
    
    <item>
      <title>Kickstart指南</title>
      <link>https://blog.abser.top/blog/kickstart%E6%8C%87%E5%8D%97/</link>
      <pubDate>Thu, 24 Jan 2019 15:43:05 +0800</pubDate>
      
      <guid>https://blog.abser.top/blog/kickstart%E6%8C%87%E5%8D%97/</guid>
      <description>Kick Start快速入门 Background Code Jam Kickstart 为同学们提供向 Google 展现自己专业能力以及走近 Google 的机会。在家就可以参加由 Google 的工程师们设计的算法题。通过参加线上测试，同学们可以直观地了解 Google 技术性岗位对编程能力的要求，也是参与 Google 校园招聘的入场券。
Requirement  G家邮箱一枚 科学上网工具 地址传送门（如果从codejam进入的话，选择分类中的kickstart）  Quickstart-Overview G家鼓励灵活的解决方案，所以施行的输入输出方案和其他的ACM在线测评不一样。
不是让你不断提交代码然后系统给你测试，而是给你数据集让你自己测试后在本地生成输出文件进行上传。
1. 下载题目数据集 .in 文件（小数据集4分钟变一次，大数据集8分钟变一次） 1. 解题并生成输出 .out 文件 1. 提交输出文件 和 代码源文件（练习测试不用提交）
PS. 每一道题都有小数据集和大数据集两个.in文件可供下载，大数据集的数据范围一般都比小数据集的范围更广，有更多的困难情况。
QuickStart 必要点  如果你想参加比赛，请在比赛期间访问你的比赛主页。如果您想练习，请访问“过去的问题”页面并选择一个回合。然后选择一个问题。
读问题，前面几段话将精确描述您的程序需要解决的问题。仔细注意极限部分。这些限制将帮助您确定处理大小数据集所需的解决方案类型。（通常会说明一些无解的数据不用考虑）
编写一个程序，在不到3分钟的时间内用所描述的小限制解决问题。确保您的程序接受输入并以给定的格式输出;如果您使用示例输入作为输入运行它，它应该准确地生成示例输出(包括“Case #”文本)。如果您不确定如何处理输入和输出，请参阅下面的标准I/O教程，了解可行的做法。
在页面顶部，单击以 solve A-small 并下载输入文件。在真正的比赛中，我们一收到下载请求就会启动一个4分钟的计时器。如果你在练习，就不会有计时器。
在该输入文件上运行程序，并将结果保存到文件中。将该文件作为输出文件提交。(在真正的比赛中，你还需要提交你的源代码。)服务器的响应方式有以下几种:
 正确示例:您提交的每个案例都完全正确!
 拒绝:您的提交被拒绝的原因与您的答案的正确性或不正确性无关。例如，您可能上传了一个输入文件或源代码，而不是您自己的输出文件。时钟仍然在运行，所以需要考虑您能否在超时之前修复这个问题(在这种情况下，您的提交将被视为不正确)。
 不正确：我们不会告诉您哪些情况是错误较小**的时间惩罚(但是解决问题总比不解决好，即使有惩罚!)
  在您解决小数据集之后，大数据集将变得可用。一旦您的程序准备好处理更高的限制，下载大型数据集。(参赛者通常只编写一个解决方案来解决两个数据集。)我们一收到下载请求就会启动一个8分钟的计时器。
与小数据集一样运行程序并提交，直到比赛结束你才知道你是否正确地解决了问题。如果您的提交被拒绝或您想提交另一个答案，您可以在8分钟的时间限制内再次尝试，但只有最后一次提交将被判定。
接着看另一个问题(左边有一个列表)。您正确解出的每个数据集都值下载链接旁边所写的点数。比赛结束时得分最多的选手排名最高。在一个小数据集上，每一次错误的提交最终被正确的回答，将会有4分钟的惩罚时间。为了引人注目，记分牌将显示“乐观”的初步结果,也就是说，它将假设每个大型提交都是正确的。比赛结束后，记分牌将显示真实的结果，包括哪些大的提交是错误的。
教程 我们现在只有一个教程，但我们将来可能会添加更多教程。虽然阅读理论很好，但我们强烈建议您练习解决实际问题以使其变得更好。您可以访问我们的 过去问题部分来完成此操作。For Fun！
“标准”解决方案：使用标准输入和输出 Kickstart鼓励灵活解决问题：我们会为您提供输入文件，并让您以自己喜欢的方式解决问题。您可以选择语言，开发环境，体系结构，库等。</description>
    </item>
    
    <item>
      <title>IPFS讲解</title>
      <link>https://blog.abser.top/blog/ipfs%E8%AE%B2%E8%A7%A3/</link>
      <pubDate>Sat, 19 Jan 2019 15:37:49 +0800</pubDate>
      
      <guid>https://blog.abser.top/blog/ipfs%E8%AE%B2%E8%A7%A3/</guid>
      <description>IPFS普及知识 行星际文件系统任务 InterPlanetary文件系统（IPFS）的目标是创建分布式Web。一种点对点超媒体协议，使网络更快，更安全，更开放。
两个&amp;rsquo;中心&amp;rsquo;问题 集中化带来了几个主要问题。第一个是当你有一个控制大量数据的中央公司时，如果无法访问这些服务器会发生什么？控制存储大量有价值和有用数据的服务器的中央公司单点故障导致完全无法访问。这种失败可能是由于攻击造成的，也可能是因为服务器离线了。
将数据存储在中心位置的第二个问题是审查。当大多数数据托管在几个主要服务器上时，政府更容易阻止对它们的访问。2017年，土耳其居民无法访问Wikipedia.com。土耳其政府禁止该网站称其为“国家安全威胁”。这也发生在2011年1月的埃及，当时政府为95％以上的公民切断了互联网和手机接入。
为什么我们使用有缺陷的系统？ 我们继续接受这种模式的真正原因是我们已经因为接入互联网而受到损害。我们希望网页以毫秒为单位加载，图像和视频无延迟地显示，当然，这一切都必须具有最高的HD或4K质量。集中服务器使公司可以完全控制他们提供此内容的速度，并相应地收取费用。我们继续这种方法的另一个原因是，确实没有一个好的选择。
IPFS→好的选择 InterPlanetary文件系统（也称为IPFS）是一种使Internet完全分布的想法。该概念将传统的“HTTP”互联网转变为对等网络，类似于BitTorrent的工作方式。
Juan Benet是IPFS的创建者和Protocol Labs的创始人。Protocol Labs是一家负责IPFS的技术研发实验室，他们还开发了Filecoin和IPLD（以及其他）。Benet在斯坦福大学学习计算机科学，并且非常关注与知识，科学和技术有关的任何事情。
Juan Benets最初的目标并不是在制作这个概念时必然会创建IPFS。他想要做的是找到一种有效的方法来移动科学数据集，这意味着数据大小可能是10-100 + GB。IPFS的设计看起来像Git和BitTorrent一起生孩子时会发生什么。BitTorrent使您能够快速地在网络上移动大型文件，Git为您提供内置的数据版本。
在创建此协议之后，Benet很快意识到其影响远大于移动大型数据集。他实际上创建了一个协议，可以取代其他流行的协议，以便我们今天通过网络访问信息。
InterPlanetary文件系统的名称来自哪里？ 当他们提出行星际文件系统（IPFS）的命名时，其想法是向互联网如何命名致敬。JCR Licklider是Arpanet（互联网的前身）的创造者，其目标是建立一个星际网络。因此，互联网对于星际网络而言确实很短。InterPlanetary采用相同的命名约定，此外，IPFS旨在成为Internet协议（IP）的文件系统（FS）。当把它们放在一起时，便有了IPFS，即互联网文件系统。我将深入探讨IPFS如何作为文件系统。但首先，了解我们今天如何从网络访问文件非常重要。
当您想从互联网上下载图像时，您可以告诉您的计算机确切地找到您要求的图像的位置。此位置通常采用URL的形式，其中包含存储照片的公司的域名，后面跟着指定文件内容的扩展名。此博客文章的示例请求如下所示：https://achainofblocks.com/ipfs-simple-guide.jpg。这种访问资源的方法称为“基于位置的寻址”，您告诉计算机他们可以访问信息的位置，并且计算机检索信息。此方法的一个问题是，如果位置不可访问（可能服务器处于脱机状态），则用户的计算机无法检索所需的信息。
服务器关闭，我们都倒闭了 使用服务器关闭时基于位置的寻址，无法通过Internet访问该服务器中包含的所有内容。但是，当服务器发生故障时，另一个用户很可能已下载该图像，并将其本地存储在其计算机上。但即使另一台计算机确实有此文件，您的计算机也无法与这些计算机连接以传输该文件。
关于内容 为了帮助解决这个问题，IPFS引入了“基于内容的寻址”的概念。在请求特定资源时使用基于内容的寻址时，您无需指定位置，只需指定所需内容即可。
每个文件都有一个唯一的哈希值，可以将其视为文件的指纹或标识。如果要访问特定文件，只需向网络询问具有指定哈希值的文件副本即可。请求完成后，IPFS网络上的某个人将提供您请求的资源。您将下载该资源，并将副本保存到您的IPFS缓存中。现在，当另一个人来并请求相同的文件时，您将能够提供给他们。这创建了一个系统，随着它的使用速度越来越快，因为共享的文件越多，它们就越容易获得，它们就是一组节点。
有改变是好事… 在这一点上，我和你有同样的问题：这个行为正确吗？我怎么知道提供给我文件的人或节点没有以某种方式篡改它？因为您使用哈希函数来检索文件，所以您可以验证收到的内容。更改文件的哈希值与更改区块链中的事务同样困难。请求具有特定散列的文件，因此在收到文件时，请确保散列与请求匹配。这与您用于验证亚马逊购买的方法相同。如果您订购了Green Socks，并且Red Socks出现，您将拒绝它们并等待您的Green Socks出现。
IPFS的另一个功能是重复数据删除，这意味着当多个用户发布同一文件时，它只在网络上创建一次。这有助于提高网络效率。
IPFS如何真正起作用 现在您已经了解了IPFS与当今传统方法的比较基础，让我们更深入地了解IPFS如何实际存储数据并使其可供用户访问。
在IPFS中，文件存储在IPFS对象中，每个Object可以存储256 kb的数据。对象还可以包含指向另一个IPFS对象的链接，链接可以存储大于256 kb的数据。例如，如果您只上传一个小文本文件，那么一个256 kb的对象应该适合您的少量文本。
但是，如果要存储图片，则会将其分解为多个对象，每个对象最大为256 kb。然后，IPFS系统将创建一个空对象，该对象将链接到构成该图片的所有对象。
这种架构非常简单，但它也非常强大，该架构真正使IPFS能够用作文件系统。如果你看一下下面的简单文件目录结构，我将解释如何将其转换为IPFS结构：
通过为每个文件和每个文件夹/目录创建1个对象，然后将文件链接到指定的目录，可以将其转换为IPFS。如果考虑到IPFS使用基于内容的寻址的话会变得更好。这意味着添加的文件是不可变的，它们永远不会被更改，非常像区块链。这意味着访问的资源是正确的数据，并且从未被更改过。
我如何更新我的数据？ IPFS支持文件版本控制，这与Git如何作为开源代码库一样工作。例如，您正在处理名为“Important Document – v1.doc”的文本文件，并且您希望与使用IFPS的人共享此文档。当您将此文件添加到IPFS时，幕后发生的事情是，IPFS将创建一个新的Commit对象。这个Object是非常基本的，它只是告诉IPFS哪个Commit在此之前，它链接到与文件相关的IPFS对象，&amp;rsquo;Important Document – v1.doc&amp;rsquo;。
现在让我们假设已经过了一段时间，你的&amp;rsquo;Important Document.doc&amp;rsquo;需要修改。只需将新文件添加到IPFS“Important Document – v2.doc”即可完成此操作，软件将为更新的文件创建新的提交对象（与原始进程相同）。此提交对象现在链接到先前的提交对象，第一个提交用作父对象。这个过程可以无休止地重复，创建一个链接的相同数据版本，所有这些都引用整个链。IPFS确保您的文件以及整个文件版本控制历史记录可供网络上的所有其他节点访问。
没有系统是完美的 到目前为止，我们已经讨论了InterPlanetary文件系统的许多有用功能和关键概念。但是，所有协议都有局限性和缺点。正如您可能想象的那样，IPFS目前面临的最大问题是保持文件可用。网络上的每个节点都保留了已下载文件的缓存，并有助于使其可用，因为其他用户需要它们。但是，在一个简单的情况下，如果一个Document由4个节点托管，并且它们全部脱机，则该文档不再可访问。
有几种方法可以解决上述问题。一种方法是激励节点保持在线并使文件可供社区使用。对可以提交给网络的存储空间的奖励，这将确保文件很可能在需要时可用。另一种方法是主动在整个网络中分发文件，确保在任何给定时间总是有足够的在线副本。你可以把它想象成大规模的冗余。
Filecoin 这个问题是Filecoin旨在解决的确切问题。Filecoin由创建IPFS的同一组创建。Filecoin是一个建立在IPFS之上的区块链，其目标是创建一个分散的存储市场。这意味着在硬盘上有额外存储空间的用户可以将其出租用作IPFS存储，并在此过程中从中赚取一些钱。您可以将Filecoin视为与Airbnb类似的服务，而不是租用您家中的可用空间，您可以租用计算机上的可用空间进行存储。Filecoin为节点创建了一种激励，使数据保持在线并尽可能长时间保留。除了保持节点在线的激励之外，它还可以跨多个节点复制数据，使其高度可用且易于访问（即使少数节点处于脱机状态）。Filecoin和IPFS具有相同的目标，即脱机优先，这意味着他们不断努力获得更好的体验，而无需调用服务器来访问资源。
这是Filecoin的一个非常高级的快速摘要。我将在未来的文章中深入研究Filecoin以及Protocol实验室中的一些其他伟大项目。
行星际关联数据（IPLD） 根据https://ipld.io：
“IPLD是内容可寻址网络的数据模型。它允许我们将所有与哈希相关的数据结构视为统一信息空间的子集，统一所有将数据与哈希作为IPLD实例链接的数据模型。“
这意味着IPLD旨在成为可互操作协议的数据模型。这种技术有很多用例。这使得能够在IPFS上运行智能合约。关键是IPLD提供的库使底层数据可以跨工具和协议进行互操作。
IPLD和Fileco都是非常复杂的项目，需要他们自己的专门文章才能完全理解。
额外的想法 我希望通过阅读本文显而易见，IPFS是一个非常雄心勃勃的项目。以权力下放为重点的大多数早期项目主要涉及货币和财务方面。IPFS实际上是建立一种更好的共享数据的方式。之前有过HTTP的挑战。然而，IPFS显然是最成熟的，并且被视为可以在未来几年中大规模采用的系统。我绝不暗示HTTP正在消失，Juan Benet自己也承认HTTP是一个很棒的协议，它仍然非常有用。但是，它是一个超过25年的协议，随着IPFS在采用中的不断增长，用例将随着技术的发展而扩展。在IPFS最终接管之前，我们很有可能会同时使用这两种协议。</description>
    </item>
    
    <item>
      <title>Hugo&#43;Github搭建个人博客</title>
      <link>https://blog.abser.top/blog/hugo-github-blog/</link>
      <pubDate>Sun, 25 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.abser.top/blog/hugo-github-blog/</guid>
      <description>前言介绍  Hugo是什么?   Hugo是一种通用的网站框架。严格来说，Hugo应该被称作静态页面生成引擎。
 官网https://gohugo.io/
 静态页面生成引擎又是什么?   静态页面生成引擎从字面上来理解，就是将你的内容生成静态网站。所谓“静态”的含义其实反映在网站页面的生成的时间。一般的web服务器（WordPress, Ghost, Drupal等等）在收到页面请求时，需要调用数据库生成页面（也就是HTML代码），再返回给用户请求。而静态网站则不需要在收到请求后生成页面，而是在整个网站建立起之前就将所有的页面全部生成完成，页面一经生成便称为静态文件，访问时直接返回现成的静态页面，不需要数据库的参与。
  那么我采用Hugo来搭建博客优点有哪些?
 访问快速.因为不需要每次访问生成页面当然，一旦网站有任何更改，静态网站生成器需要重新生成所有的与更改相关的页面。然后由于Hugo是用Go语言编写的在生成速度这方面做的非常好.5000篇文章的博客生成时间只需要6秒钟.对比其他的静态页面生成引擎动不动几分钟的时间优势非常明显 采用静态页面搭建博客,维护起来非常简单.事实上根本不需要什么维护，完全不用考虑复杂的运行时间，依赖和数据库的问题。再有也不用担心安全性的问题，没有数据库，网站注入什么的也无从下手 无依赖.低消耗资源. 专注于写作.我认为对于个人博客来说，应该将时间花在内容上而不是各种折腾网站。Hugo会将Markdown格式的内容和设置好模版一起，生成漂亮干净的页面。你只需要把Markdown文件放在content文件夹下面.一切水到渠成  听起来很棒的样子那搭建起来会不会非常复杂?
  不会.跟着教程走下来.只需要十分钟.
开始 需求 1.Hugo工具 2.GitHub个人账号 3.Git工具  安装 如果说速度快是Hugo的第一大优点，那么安装简单应该就是Hugo的第二大优点。对于Mac用户，没有brew的话先安装brew，在命令行里敲：
$ ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;  然后再敲一行安装Hugo:
$ brew new Hugo  当然你也可以在这里直接下载对应系统的binary文件，解压就行了。
生成 site 目录 hugo new site blog cd blog git init #Congratulations! Your new Hugo site is created in /Users/steven/MyProjects/Demo/blog.</description>
    </item>
    
    <item>
      <title>Learn Gorm</title>
      <link>https://blog.abser.top/blog/gorm-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 11 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.abser.top/blog/gorm-%E5%85%A5%E9%97%A8/</guid>
      <description>ORM（Object Relation Mapping），对象关系映射，实际上就是对数据库的操作进行封装，对上层开发人员屏蔽数据操作的细节，开发人员看到的就是一个个对象，大大简化了开发工作，提高了生产效率
好了，下面我以这个点赞评论系统为例，介绍一下 gorm 的简单用法，以下使用的完整代码：https://github.com/hatlonely/...
#gorm 用法介绍 ##库安装 go get -u github.com/jinzhu/gorm ##数据库连接
import ( &amp;quot;github.com/jinzhu/gorm&amp;quot; _ &amp;quot;github.com/jinzhu/gorm/dialects/mysql&amp;quot; ） var db *gorm.DB func init() { var err error db, err = gorm.Open(&amp;quot;mysql&amp;quot;, &amp;quot;&amp;lt;user&amp;gt;:&amp;lt;password&amp;gt;/&amp;lt;database&amp;gt;?charset=utf8&amp;amp;parseTime=True&amp;amp;loc=Local&amp;quot;) if err != nil { panic(err) } }  连接比较简单，直接调用 gorm.Open 传入数据库地址即可
github.com/jinzhu/gorm/dialects/mysql 是 golang 的 mysql 驱动，实际上就是 github.com/go-sql-driver/mysql 作者这里为了好记，重新弄了个名字
这里我用的 mysql，实际上支持基本上所有主流的关系数据库，连接方式上略有不同
db.DB().SetMaxIdleConns(10) db.DB().SetMaxOpenConns(100) 还可以使用 db.DB() 对象设置连接池信息
###表定义 先来定义一个点赞表，这里面一条记录表示某个用户在某个时刻对某篇文章点了一个赞，用 ip + ua 来标识用户，title 标识文章标题
type Like struct { ID int `gorm:&amp;quot;primary_key&amp;quot;` Ip string `gorm:&amp;quot;type:varchar(20);not null;index:ip_idx&amp;quot;` Ua string `gorm:&amp;quot;type:varchar(256);not null;&amp;quot;` Title string `gorm:&amp;quot;type:varchar(128);not null;index:title_idx&amp;quot;` Hash uint64 `gorm:&amp;quot;unique_index:hash_idx;&amp;quot;` CreatedAt time.</description>
    </item>
    
  </channel>
</rss>